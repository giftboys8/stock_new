# 后端API实现 - 最终执行方案

**日期**: 2026-01-28
**状态**: ✅ 方案确定，等待执行确认

---

## 📊 数据源现状总结

### ✅ 可用接口（100%可用）

| 接口 | 数据量 | 用途 |
|------|--------|------|
| `stock_info_a_code_name()` | 5474只 | A股列表 |
| `stock_zh_a_hist()` | 历史K线 | 历史行情、技术分析 |
| `stock_individual_info_em()` | 个股信息 | 股票详情 |

### ❌ 不可用接口（代理问题）

| 接口 | 问题 | 影响 |
|------|------|------|
| `stock_zh_a_spot_em()` | 代理错误 | 实时行情 |
| `stock_board_industry_name_em()` | 代理错误 | 行业数据 |
| `stock_financial_analysis_indicator()` | 数据为空 | 财务指标 |

### 💡 变通方案

**问题**: 实时行情接口不可用怎么办？

**解决方案**:
1. **方案A**: 使用`stock_zh_a_hist()`的最新一天数据作为"实时"数据
   - ✅ 接口100%可用
   - ✅ 包含OHLCV数据
   - ⚠️ 可能有几分钟延迟（可接受）

2. **方案B**: 在代码中添加重试机制
   - 尝试多个数据源
   - 降级到历史数据

3. **方案C**: 前端显示时标注"数据延迟"
   - 明确告知用户数据不是秒级实时

**我的推荐**: 方案A + 方案C的组合

---

## 🎯 Redis缓存方案（已确认）

### 当前阶段：使用Python内存缓存

**理由**:
- ✅ akshare本身有请求限制（每次3-4秒），不会过度请求
- ✅ 我们使用定时任务（小时级更新），不是实时查询
- ✅ Python内存缓存完全够用（5分钟TTL）
- ✅ **Redis成本**：阿里云Redis ¥50-200/月（最小规格）

**实现**:
```python
from functools import lru_cache
import time

class SimpleCache:
    def __init__(self, ttl=300):
        self.cache = {}
        self.ttl = ttl

    def get(self, key):
        if key in self.cache:
            data, timestamp = self.cache[key]
            if time.time() - timestamp < self.ttl:
                return data
        return None

    def set(self, key, value):
        self.cache[key] = (value, time.time())
```

**未来扩展**:
- 如果多实例部署 → 考虑Redis
- 如果缓存数据量>1GB → 考虑Redis
- 当前：单机部署，内存缓存足够

---

## 🚀 API接口实现方案

### 核心API（全部实现）

#### 1. GET /api/stocks - 获取股票列表
```python
# 数据源: stock_info_a_code_name() ✅
# 支持分页、筛选
# 返回: {stocks: [...], total: 5474}
```

#### 2. GET /api/stocks/:code - 获取个股详情
```python
# 数据源: stock_individual_info_em() + stock_zh_a_hist() ✅
# 返回: 基本信息 + 最新行情（历史数据最新一天）
```

#### 3. POST /api/screen - 执行股票筛选
```python
# 数据源: stock_info_a_code_name() + 筛选逻辑
# 筛选条件: PE、PB、市值、涨跌幅
# 返回: 符合条件的股票列表
```

#### 4. GET /api/stocks/:id/history - 获取历史K线
```python
# 数据源: stock_zh_a_hist() ✅
# 用途: 前端图表展示
# 参数: period(daily/weekly), start_date, end_date
```

#### 5. POST /api/screening-history - 保存筛选历史
```python
# 存储: SQLite database
# 返回: 保存成功
```

#### 6. GET /api/screening-history - 获取历史记录
```python
# 数据源: SQLite database
# 支持分页、筛选
```

#### 7. DELETE /api/screening-history/:id - 删除历史
```python
# 操作: SQLite database
```

#### 8. GET /api/watchlist - 自选股列表
```python
# 数据源: SQLite database
```

#### 9. POST /api/watchlist - 添加自选股
```python
# 操作: SQLite database
```

#### 10. DELETE /api/watchlist/:id - 删除自选股
```python
# 操作: SQLite database
```

---

## ⚠️ 完整的错误处理方案

### 三层错误处理机制

#### 第1层：数据源重试
```python
def get_stock_quote_with_retry(code: str, max_retries=3):
    """带重试的数据获取"""

    # 尝试多个数据源
    sources = [
        lambda: ak.stock_zh_a_spot_em(),  # 优先：东财
        lambda: ak.stock_zh_a_spot(),       # 备用：新浪
        lambda: get_from_history(code),     # 降级：历史数据
    ]

    for source in sources:
        try:
            return source()
        except Exception as e:
            logger.warning(f"数据源失败，尝试下一个: {e}")
            continue

    # 全部失败，返回缓存数据
    return cache.get(code)
```

#### 第2层：友好错误响应
```python
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """全局异常处理"""
    logger.error(f"API错误: {exc}")

    return JSONResponse(
        status_code=500,
        content={
            "error": "服务暂时不可用",
            "message": "请稍后重试",
            "detail": str(exc) if DEBUG else None
        }
    )
```

#### 第3层：详细日志记录
```python
# 日志级别
logger.debug()   # 调试信息（开发环境）
logger.info()    # 关键操作（启动、停止）
logger.warning() # 警告（重试、降级）
logger.error()   # 错误（异常）

# 日志文件
logs/
  ├── app.log         # 所有日志
  ├── error.log       # 只记录错误
  └── access.log      # API访问日志
```

---

## 📁 实施步骤（预计3-4天）

### Day 1: 核心数据获取模块
- [ ] 改进data_fetcher.py（添加重试、缓存）
- [ ] 测试所有数据源
- [ ] 编写单元测试

### Day 2: 核心API接口
- [ ] 实现GET /api/stocks
- [ ] 实现GET /api/stocks/:code
- [ ] 实现POST /api/screen
- [ ] 实现GET /api/stocks/:id/history

### Day 3: 辅助功能
- [ ] 实现筛选历史CRUD
- [ ] 实现自选股CRUD
- [ ] 添加错误处理和日志

### Day 4: 测试和优化
- [ ] 集成测试
- [ ] 性能优化
- [ ] 文档完善

---

## 💰 成本估算

### 开发阶段
| 项目 | 成本 |
|------|------|
| 开发时间 | 3-4天 |
| 人力成本 | 0（自己开发）|
| 测试成本 | 0（本地测试）|

### 运行阶段（月成本）
| 项目 | 方案A（最小） | 方案B（推荐） |
|------|---------------|---------------|
| 服务器 | ¥0（本地） | ¥50-100（云服务器） |
| 数据源 | ¥0（akshare免费） | ¥0 |
| 缓存 | ¥0（内存） | ¥0（内存） |
| **总计** | **¥0/月** | **¥50-100/月** |

**注意**:
- Redis暂时不需要（未来按需添加）
- akshare完全免费（无请求限制）
- 主要成本在云服务器（如果部署的话）

---

## ✅ 最终确认清单

### 您的需求确认：
- [x] 代理问题：选择方案A（已确认关闭代理，但仍有问题 → 使用变通方案）
- [x] API接口：全部实现（10个接口）
- [x] Redis缓存：先用Python内存缓存
- [x] 行业/财务数据：简化需求，暂时不需要

### 数据源方案：
- [x] 股票列表：stock_info_a_code_name() ✅
- [x] 实时行情：stock_zh_a_hist()最新一天 ✅
- [x] 历史K线：stock_zh_a_hist() ✅
- [x] 行业数据：暂不实现
- [x] 财务数据：暂不实现

### 技术方案：
- [x] 错误处理：三层机制（重试+友好响应+日志）
- [x] 缓存：Python内存缓存（5分钟TTL）
- [x] 数据库：SQLite（开发）→ PostgreSQL（生产）

---

## 🎬 下一步行动

### 等待您的确认：

**问题1**: 行业数据和财务数据暂时不做，可以接受吗？
- 如果可以，我们使用基础筛选（价格、涨跌幅、成交量）
- 如果不行，我需要找其他数据源

**问题2**: 实时行情使用历史数据的最新一天（可能有几分钟延迟），可以接受吗？
- 对于选股系统，几分钟延迟完全没问题
- 前端显示时标注"数据时间"

**问题3**: 是否立即开始实施？
- 如果确认，我立即开始实现API接口
- 预计3-4天完成全部10个接口

---

## 📝 执行计划

如果您确认上述方案，我将按以下顺序实施：

1. **立即执行**（今天）:
   - 改进data_fetcher.py（重试+缓存+错误处理）
   - 实现GET /api/stocks（股票列表+筛选）

2. **明天**:
   - 实现GET /api/stocks/:code（个股详情）
   - 实现POST /api/screen（筛选功能）
   - 实现GET /api/stocks/:id/history（历史K线）

3. **后天**:
   - 实现筛选历史CRUD（4个接口）
   - 实现自选股CRUD（3个接口）
   - 完善错误处理和日志

4. **第4天**:
   - 集成测试
   - 前后端联调
   - 文档完善

---

**请您确认**:
1. ✅ 行业/财务数据暂时不做？
2. ✅ 使用历史数据最新一天作为实时行情？
3. ✅ 立即开始实施？

回复"确认"或提出其他要求，我立即开始！🚀
